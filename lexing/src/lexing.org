#+property: tangle lib.rs
#+title: lexing
- test_lexing
- test_lexing_unicode
- fix `LexError`
- handle escape in quotation
* prolog

*** feature

    #+begin_src rust
    #![feature (uniform_paths)]

    #![allow (unused_parens)]
    #![allow (dead_code)]
    #![allow (unused_macros)]
    #+end_src

*** use

    #+begin_src rust
    use std::collections::HashSet;
    #+end_src

* Token

*** Token

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub enum Token <'a> {
        Quotation {
            span: Span,
            quotation_mark: char,
            string: &'a str,
        },
        Word {
            span: Span,
            word: &'a str,
        },
        Char {
            span: Span,
            ch: char,
        },
    }
    #+end_src

*** Token::span

    #+begin_src rust
    impl <'a> Token <'a> {
        pub fn span (&self) -> Span {
            match self {
                Token::Quotation { span, .. } => span.clone (),
                Token::Word { span, .. } => span.clone (),
                Token::Char { span, .. } => span.clone (),
            }
        }
    }
    #+end_src

*** Token::len

    #+begin_src rust
    impl <'a> Token <'a> {
        pub fn len (&self) -> usize {
            self.span () .len ()
        }
    }
    #+end_src

*** Span

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct Span {
        pub lo: usize,
        pub hi: usize,
    }
    #+end_src

*** Span::len

    #+begin_src rust
    impl Span {
        pub fn len (&self) -> usize {
            self.hi - self.lo
        }
    }
    #+end_src

*** LexError

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct LexError;
    #+end_src

* CharTable

*** CharTable

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    pub struct CharTable {
        pub quotation_mark_set: HashSet <char>,
        pub space_set: HashSet <char>,
        pub char_set: HashSet <char>,
    }
    #+end_src

*** CharTable::new

    #+begin_src rust
    impl CharTable {
        fn new () -> Self {
            CharTable {
                quotation_mark_set: HashSet::new (),
                space_set: HashSet::new (),
                char_set: HashSet::new (),
            }
        }
    }
    #+end_src

*** CharTable::quotation_mark

    #+begin_src rust
    impl CharTable {
         fn quotation_mark (mut self, ch: char) -> Self {
            self.quotation_mark_set.insert (ch);
            self
         }
    }
    #+end_src

*** CharTable::space

    #+begin_src rust
    impl CharTable {
        fn space (mut self, ch: char) -> Self {
            self.space_set.insert (ch);
            self
        }
    }
    #+end_src

*** CharTable::char

    #+begin_src rust
    impl CharTable {
        fn char (mut self, ch: char) -> Self {
            self.char_set.insert (ch);
            self
        }
    }
    #+end_src

*** CharTable::char_p

    #+begin_src rust
    impl CharTable {
        fn char_p (&self, ch: char) -> bool {
            self.char_set.contains (&ch)
        }
    }
    #+end_src

*** CharTable::space_p

    #+begin_src rust
    impl CharTable {
        fn space_p (&self, ch: char) -> bool {
            self.space_set.contains (&ch)
        }
    }
    #+end_src

*** CharTable::quotation_mark_p

    #+begin_src rust
    impl CharTable {
        fn quotation_mark_p (&self, ch: char) -> bool {
            self.quotation_mark_set.contains (&ch)
        }
    }
    #+end_src

*** CharTable::lex

    #+begin_src rust
    impl <'a> CharTable {
        pub fn lex (
            &self,
            input: &'a str,
        ) -> Result <Vec <Token <'a>>, LexError> {
            let lexing = Lexing {
                cursor: 0,
                char_table: self.clone (),
                token_vec: Vec::new (),
                input,
            };
            lexing.run ()
        }
    }
    #+end_src

* Lexing

*** Lexing

    #+begin_src rust
    #[derive (Clone)]
    #[derive (Debug)]
    #[derive (PartialEq, Eq)]
    struct Lexing <'a> {
        cursor: usize,
        input: &'a str,
        char_table: CharTable,
        token_vec: Vec <Token <'a>>,
    }
    #+end_src

*** Lexing::run

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn run (
            mut self,
        ) -> Result <Vec <Token <'a>>, LexError> {
            loop {
                self.ignore_space ();
                if self.finished_p () {
                    return Ok (self.token_vec);
                }
                self.next_token ()?;
            }
        }
    }
    #+end_src

*** Lexing::finished_p

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn finished_p (&self) -> bool {
            self.cursor == self.input.len ()
        }
    }
    #+end_src

*** Lexing::ignore_space

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn ignore_space (&mut self) {
            loop {
                let progress = &self.input [self.cursor ..];
                if let Some (ch) = progress.chars () .next () {
                    if self.char_table.space_p (ch) {
                        self.cursor += ch.len_utf8 ();
                    } else {
                        return;
                    }
                } else {
                    return;
                }
            }
        }
    }
    #+end_src

*** Lexing::next_token

    #+begin_src rust
    impl <'a> Lexing <'a> {
        pub fn next_token (
            &mut self,
        ) -> Result <(), LexError> {
            let progress = &self.input [self.cursor ..];
            let ch = progress.chars () .next () .unwrap ();
            if self.char_table.char_p (ch) {
                self.next_char (ch)
            } else if self.char_table.quotation_mark_p (ch) {
                self.next_quote (ch)
            } else {
                self.next_word ()
            }
        }
    }
    #+end_src

*** Lexing::next_char

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn next_char (
            &mut self, ch: char,
        ) -> Result <(), LexError> {
            let lo = self.cursor;
            let ch_len = ch.len_utf8 ();
            self.cursor += ch_len;
            let hi = self.cursor;
            let span = Span { lo, hi };
            let token = Token::Char { span, ch };
            self.token_vec.push (token);
            Ok (())
        }
    }
    #+end_src

*** Lexing::next_quote

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn next_quote (
            &mut self, quotation_mark: char,
        ) -> Result <(), LexError> {
            let lo = self.cursor;
            let ch_len = quotation_mark.len_utf8 ();
            self.cursor += ch_len;
            let progress = &self.input [self.cursor ..];
            if let Some (quote_end) = progress.find (quotation_mark) {
                let string = &progress [.. quote_end];
                self.cursor += string.len ();
                self.cursor += ch_len;
                let hi = self.cursor;
                let span = Span { lo, hi };
                let token = Token::Quotation {
                    span, quotation_mark, string,
                };
                self.token_vec.push (token);
                Ok (())
            } else {
                Err (LexError)
            }
        }
    }
    #+end_src

*** Lexing::goto_word_end

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn goto_word_end (&mut self) {
            loop {
                let progress = &self.input [self.cursor ..];
                if let Some (ch) = progress.chars () .next () {
                    if self.char_table.space_p (ch) {
                        return;
                    } else if self.char_table.char_p (ch) {
                        return;
                    } else if self.char_table.quotation_mark_p (ch) {
                        return;
                    } else {
                        self.cursor += ch.len_utf8 ();
                    }
                } else {
                    return;
                }
            }
        }
    }
    #+end_src

*** Lexing::next_word

    #+begin_src rust
    impl <'a> Lexing <'a> {
        fn next_word (
            &mut self,
        ) -> Result <(), LexError> {
            let lo = self.cursor;
            self.goto_word_end ();
            let hi = self.cursor;
            let word = &self.input [lo .. hi];
            let span = Span { lo, hi };
            let token = Token::Word {
                span, word,
            };
            self.token_vec.push (token);
            Ok (())
        }
    }
    #+end_src

* test

*** test_lexing

    #+begin_src rust
    #[test]
    fn test_lexing () -> Result<(), LexError> {
        let char_table = CharTable::new ()
            .quotation_mark ('"')
            .space ('\n') .space ('\t') .space (' ')
            .char ('(') .char (')')
            .char ('[') .char (']')
            .char ('{') .char ('}')
            .char (';');
        let input = r#"
        "sss" aaa "sss" bb "sss" c;
        "#;
        let token_vec = char_table.lex (input)?;
        println! ("- token_vec = {:#?}", token_vec);
        Ok (())
    }
    #+end_src

*** play

    #+begin_src rust
    #[test]
    fn play () {

    }
    #+end_src
